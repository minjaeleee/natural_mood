{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nconst useInfiniteScroll = targetEl => {\n  _s();\n  const observerRef = useRef(null);\n  const [intersecting, setIntersecting] = useState(false);\n  const getObserver = useCallback(() => {\n    const callback = (entries, observer) => {\n      console.log(\"entries\", entries);\n      console.log(\"observer\", observer);\n    };\n    const what = new IntersectionObserver(callback);\n    if (!observerRef.current) {\n      observerRef.current = new IntersectionObserver(entries => setIntersecting(\n      // 없으면 intersecting false, 있으면 intersecting true\n      entries.some(entry => entry.isIntersecting)));\n    }\n    return observerRef.current;\n  }, [observerRef.current]);\n  useEffect(() => {\n    if (targetEl.current) getObserver().observe(targetEl.current);\n    return () => {\n      getObserver().disconnect();\n    };\n  }, [targetEl.current]);\n  return intersecting;\n};\n_s(useInfiniteScroll, \"wgJwkE67wQsXc1eiCmrL0CTwPqc=\");\nexport default useInfiniteScroll;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useInfiniteScroll","targetEl","_s","observerRef","intersecting","setIntersecting","getObserver","callback","entries","observer","console","log","what","IntersectionObserver","current","some","entry","isIntersecting","observe","disconnect"],"sources":["/Users/minjaelee/Desktop/development/natural_mood/src/useHook/useInfiniteScroll.tsx"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react'\n\nconst useInfiniteScroll = targetEl => {\n  const observerRef = useRef(null)\n  const [intersecting, setIntersecting] = useState(false)\n\n  const getObserver = useCallback(() => {\n    const callback = (entries, observer) => {\n      console.log(\"entries\",entries)\n      console.log(\"observer\",observer)\n    }\n    const what = new IntersectionObserver(callback)\n    if (!observerRef.current) {\n      observerRef.current = new IntersectionObserver(entries => setIntersecting(\n        // 없으면 intersecting false, 있으면 intersecting true\n        entries.some(entry => entry.isIntersecting)\n      ))\n    }\n\n    return observerRef.current\n  }, [observerRef.current])\n\n  useEffect(() => {\n    if (targetEl.current) getObserver().observe(targetEl.current)\n    return () => {\n      getObserver().disconnect()\n    }\n  }, [targetEl.current])\n\n  return intersecting\n}\n\nexport default useInfiniteScroll"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,MAAM,EAAEC,WAAW,QAAQ,OAAO;AAEhE,MAAMC,iBAAiB,GAAGC,QAAQ,IAAI;EAAAC,EAAA;EACpC,MAAMC,WAAW,GAAGL,MAAM,CAAC,IAAI,CAAC;EAChC,MAAM,CAACM,YAAY,EAAEC,eAAe,CAAC,GAAGT,QAAQ,CAAC,KAAK,CAAC;EAEvD,MAAMU,WAAW,GAAGP,WAAW,CAAC,MAAM;IACpC,MAAMQ,QAAQ,GAAGA,CAACC,OAAO,EAAEC,QAAQ,KAAK;MACtCC,OAAO,CAACC,GAAG,CAAC,SAAS,EAACH,OAAO,CAAC;MAC9BE,OAAO,CAACC,GAAG,CAAC,UAAU,EAACF,QAAQ,CAAC;IAClC,CAAC;IACD,MAAMG,IAAI,GAAG,IAAIC,oBAAoB,CAACN,QAAQ,CAAC;IAC/C,IAAI,CAACJ,WAAW,CAACW,OAAO,EAAE;MACxBX,WAAW,CAACW,OAAO,GAAG,IAAID,oBAAoB,CAACL,OAAO,IAAIH,eAAe;MACvE;MACAG,OAAO,CAACO,IAAI,CAACC,KAAK,IAAIA,KAAK,CAACC,cAAc,CAAC,CAC5C,CAAC;IACJ;IAEA,OAAOd,WAAW,CAACW,OAAO;EAC5B,CAAC,EAAE,CAACX,WAAW,CAACW,OAAO,CAAC,CAAC;EAEzBjB,SAAS,CAAC,MAAM;IACd,IAAII,QAAQ,CAACa,OAAO,EAAER,WAAW,EAAE,CAACY,OAAO,CAACjB,QAAQ,CAACa,OAAO,CAAC;IAC7D,OAAO,MAAM;MACXR,WAAW,EAAE,CAACa,UAAU,EAAE;IAC5B,CAAC;EACH,CAAC,EAAE,CAAClB,QAAQ,CAACa,OAAO,CAAC,CAAC;EAEtB,OAAOV,YAAY;AACrB,CAAC;AAAAF,EAAA,CA5BKF,iBAAiB;AA8BvB,eAAeA,iBAAiB"},"metadata":{},"sourceType":"module","externalDependencies":[]}